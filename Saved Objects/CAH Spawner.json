{
  "SaveName": "",
  "Date": "",
  "VersionNumber": "",
  "GameMode": "",
  "GameType": "",
  "GameComplexity": "",
  "Tags": [],
  "Gravity": 0.5,
  "PlayArea": 0.5,
  "Table": "",
  "Sky": "",
  "Note": "",
  "TabStates": {},
  "LuaScript": "",
  "LuaScriptState": "",
  "XmlUI": "",
  "ObjectStates": [
    {
      "GUID": "98223e",
      "Name": "Custom_Token",
      "Transform": {
        "posX": 30.79999,
        "posY": 1.01000106,
        "posZ": 13.9999971,
        "rotX": 1.92900828E-07,
        "rotY": 179.975159,
        "rotZ": 4.71321528E-06,
        "scaleX": 0.8605225,
        "scaleY": 1.0,
        "scaleZ": 0.8605225
      },
      "Nickname": "CAH Spawner",
      "Description": "Expects 10x7 deck sheets",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.0,
        "g": 0.0,
        "b": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": false,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "CustomImage": {
        "ImageURL": "http://cloud-3.steamusercontent.com/ugc/958597478463059274/DE73B64E1B5C6F272EA3BEE5EF458E73E48FF03D/",
        "ImageSecondaryURL": "",
        "ImageScalar": 1.0,
        "WidthScale": 0.0,
        "CustomToken": {
          "Thickness": 0.1,
          "MergeDistancePixels": 5.0,
          "StandUp": false,
          "Stackable": false
        }
      },
      "LuaScript": "-- Bundled by luabundle {\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"__root\", function(require, _LOADED, __bundle_register, __bundle_modules)\nlocal Decker = require(\"Decker\")\r\n\r\nlocal whiteCardMode = true\r\n\r\nlocal white_back = \"https://i.imgur.com/GoAeXVS.png\"\r\nlocal black_back = \"https://i.imgur.com/oXc4cFw.png\"\r\n\r\nfunction onLoad()\r\n\tself.createButton({\r\n\t\tclick_function = 'spawnDeck',\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = 'Spawn Deck',\r\n\t\tposition       = {0,0.1,2.2},\r\n\t\twidth          = 1200,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 200,\r\n\t\trotation       = {-20,0,0},\r\n\t\tcolor          = {1,1,1},\r\n\t\t})\r\n\tself.createButton({\r\n\t\tclick_function = 'colorToggle',\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = '[White]    Black',\r\n\t\tposition       = {0,0.1,1.5},\r\n\t\twidth          = 2900,\r\n\t\theight         = 450,\r\n\t\tfont_size      = 400,\r\n\t\tscale          = {0.5,0.5,0.5},\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"URL\",\r\n\t\tposition       = {-0.4, 0.1, -1.3},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 2300,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 150,\r\n\t\t--value          = \"https://i.imgur.com/vDV9Svz.png\",\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"#\",\r\n\t\tposition       = {1.3, 0.1, -1.3},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 600,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 350,\r\n\t\tvalue          = \"69\",\r\n\t\tvalidation     = 2,\r\n\t\ttab            = 2,\r\n\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"URL\",\r\n\t\tposition       = {-0.4, 0.1, -.8},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 2300,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 150,\r\n\t\t--value          = \"https://i.imgur.com/FZfN44E.png\",\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"#\",\r\n\t\tposition       = {1.3, 0.1, -.8},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 600,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 350,\r\n\t\tvalidation     = 2,\r\n\t\t--value          = \"10\",\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"URL\",\r\n\t\tposition       = {-0.4, 0.1, -.3},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 2300,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 150,\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"#\",\r\n\t\tposition       = {1.3, 0.1, -.3},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 600,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 350,\r\n\t\tvalidation     = 2,\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"URL\",\r\n\t\tposition       = {-0.4, 0.1, .2},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 2300,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 150,\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"#\",\r\n\t\tposition       = {1.3, 0.1, .2},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 600,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 350,\r\n\t\tvalidation     = 2,\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"URL\",\r\n\t\tposition       = {-0.4, 0.1, .7},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 2300,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 150,\r\n\t\ttab            = 2,\r\n\t\t})\r\n\tself.createInput({\r\n\t\tinput_function = \"url_1\",\r\n\t\tfunction_owner = self,\r\n\t\tlabel          = \"#\",\r\n\t\tposition       = {1.3, 0.1, .7},\r\n\t\tscale          = {0.5, 0.5, 0.5},\r\n\t\twidth          = 600,\r\n\t\theight         = 400,\r\n\t\tfont_size      = 350,\r\n\t\tvalidation     = 2,\r\n\t\ttab            = 2,\r\n\t\t})\r\n\t\t--]]\r\n\tself.setColorTint({r=1,g=1,b=1})\r\nend\r\n\r\nlocal urls = {}\r\nlocal cardCounts = {}\r\n\r\nfunction spawnDeck()\r\n\tcount = 1\r\n\tfor _,input in ipairs(self.getInputs()) do\r\n\t\tlocal index = math.floor(count/2+.5)\r\n\t\tif math.fmod(count, 2) == 0 then\r\n\t\t\tlocal number = 0\r\n\t\t\tif input.value ~= \"\" then\r\n\t\t\t\tnumber = tonumber(input.value)\r\n\t\t\t\tcardCounts[index] = number\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tlocal url = \"\"\r\n\t\t\tif input.value ~= \"\" then\r\n\t\t\t\turl = input.value\r\n\t\t\tend\r\n\t\t\turls[index] = url\r\n\t\tend\r\n\t\tcount = count + 1\r\n\tend\r\n\tfor index,url in ipairs(urls) do\r\n\t\tif url ~= \"\" then\r\n\t\t\tlocal needed_rows = 7\r\n\t\t\tlocal cardBack = white_back\r\n\t\t\tlocal downAmount = 3.5\r\n\t\t\tif not whiteCardMode then\r\n\t\t\t\tcardBack = black_back\r\n\t\t\t\tdownAmount = 7\r\n\t\t\tend\r\n\t\t\tif cardCounts[index] == 1 then\r\n\t\t\t\tlocal cardAsset = Decker.Asset(url, cardBack)\r\n\r\n\t\t\t\tDecker.Card(cardAsset, 1, 1):spawn({position = {self.getPosition().x+(2.5*(index-1)), 3, self.getPosition().z-downAmount}})\r\n\t\t\telse\r\n\t\t\t\t--[[\r\n\t\t\t\tif cardCounts[index] < 69 then\r\n\t\t\t        needed_rows = math.floor(cardCounts[index]/10)+1\r\n\t\t\t        if cardCounts[index] < 10 then\r\n\t\t\t            needed_rows = needed_rows + 1\r\n\t\t\t\t\tend\r\n\t\t\t\tend--]]\r\n\t\t\t\tlocal cardAsset = Decker.Asset(url, cardBack, {width = 10, height = needed_rows})\r\n\t\t\t\tDecker.AssetDeck(cardAsset, cardCounts[index]):spawn({position = {self.getPosition().x+(2.5*(index-1)), 3, self.getPosition().z-downAmount}})\r\n\t\t\tend\r\n\t\t\t--local myDeck = Decker.Deck(cards)\r\n\t\t\t--myDeck:spawn({position = {2.5*index, 3, 0}})\r\n\t\tend\r\n\tend\r\nend\r\n\r\nfunction url_1(obj, color, input, stillEditing)\r\n\tif not stillEditing then\r\n\r\n\tend\r\nend\r\n\r\nfunction url_2(obj, color, input, stillEditing)\r\n\tif not stillEditing then\r\n\r\n\tend\r\nend\r\n\r\nfunction colorToggle(obj, color)\r\n\twhiteCardMode = not whiteCardMode\r\n\tfor ind,input in ipairs(self.getInputs()) do\r\n\t\tlocal newValue = \"\"\r\n\t\tif ind == 2 then\r\n\t\t\tnewValue = \"69\"\r\n\t\tend\r\n\t\tself.editInput({\r\n\t\t\tindex          = ind-1,\r\n\t\t\tvalue          = newValue,\r\n\t\t})\r\n\tend\r\n\tif whiteCardMode then\r\n\t\tself.setColorTint({r=1,g=1,b=1})\r\n\t\tself.editButton({\r\n\t\t\tindex          = 1,\r\n\t\t\tlabel          = '[White]    Black',\r\n\t\t})\r\n\telse\r\n\t\tself.setColorTint({r=0,g=0,b=0})\r\n\t\tself.editButton({\r\n\t\t\tindex          = 1,\r\n\t\t\tlabel          = 'White    [Black]',\r\n\t\t})\r\n\tend\r\n\r\nend\r\n\nend)\n__bundle_register(\"Decker\", function(require, _LOADED, __bundle_register, __bundle_modules)\nlocal Decker = {}\n\n-- provide unique ID starting from 20 for present decks\nlocal nextID, recheckNextID\ndo\n    local _nextID = 20\n    nextID = function()\n        _nextID = _nextID + 1\n        return tostring(_nextID)\n    end\n\n    local function recheckObjNextDeckID(obj)\n        for deckID in pairs(obj.getData().CustomDeck or {}) do\n            if deckID >= _nextID then\n                _nextID = deckID\n            end\n        end\n    end\n\n    recheckNextID = function()\n        local initialNextID = _nextID\n        for _, obj in ipairs(getAllObjects()) do\n            recheckObjNextDeckID(obj)\n        end\n        return _nextID > initialNextID\n    end\nend\n\n-- Asset signature (equality comparison)\nlocal function assetSignature(assetData)\n    return table.concat({\n        assetData.FaceURL,\n        assetData.BackURL,\n        assetData.NumWidth,\n        assetData.NumHeight,\n        assetData.BackIsHidden and 'hb' or '',\n        assetData.UniqueBack and 'ub' or ''\n    })\nend\n-- Asset ID storage to avoid new ones for identical assets\nlocal idLookup = {}\nlocal function assetID(assetData)\n    local sig = assetSignature(assetData)\n    local key = idLookup[sig]\n    if not key then\n        key = nextID()\n        idLookup[sig] = key\n    end\n    return key\nend\n\nlocal assetMeta = {\n    deck = function(self, cardNum, options)\n        return Decker.AssetDeck(self, cardNum, options)\n    end\n}\nassetMeta = {__index = assetMeta}\n\n-- Create a new CustomDeck asset\nfunction Decker.Asset(face, back, options)\n    local asset = {}\n    options = options or {}\n    asset.data = {\n        FaceURL = face or error('Decker.Asset: faceImg link required'),\n        BackURL = back or error('Decker.Asset: backImg link required'),\n        NumWidth = options.width or 1,\n        NumHeight = options.height or 1,\n        BackIsHidden = options.hiddenBack or false,\n        UniqueBack = options.uniqueBack or false\n    }\n    -- Reuse ID if asset existing\n    asset.id = assetID(asset.data)\n    return setmetatable(asset, assetMeta)\nend\n-- Pull a Decker.Asset from card JSONs CustomDeck entry\nlocal function assetFromData(assetData)\n    return setmetatable({data = assetData, id = assetID(assetData)}, assetMeta)\nend\n\n-- Create a base for JSON objects\nfunction Decker.BaseObject()\n    return {\n        Name = 'Base',\n        Transform = {\n            posX = 0, posY = 5, posZ = 0,\n            rotX = 0, rotY = 0, rotZ = 0,\n            scaleX = 1, scaleY = 1, scaleZ = 1\n        },\n        Nickname = '',\n        Description = '',\n        Value = 0,\n        Tags = {},\n        ColorDiffuse = { r = 1, g = 1, b = 1 },\n        Locked = false,\n        Grid = true,\n        Snap = true,\n        Autoraise = true,\n        Sticky = true,\n        Tooltip = true,\n        GridProjection = false,\n        Hands = true,\n        XmlUI = '',\n        LuaScript = '',\n        LuaScriptState = '',\n        GUID = 'deadbf'\n    }\nend\n-- Typical paramters map with defaults\nlocal commonMap = {\n    name   = {field = 'Nickname',    default = ''},\n    value   = {field = 'Value',    default = 0},\n    tags   = {field = 'Tags',   default = {}},\n    desc   = {field = 'Description', default = ''},\n    script = {field = 'LuaScript',   default = ''},\n    xmlui  = {field = 'XmlUI',       default = ''},\n    scriptState = {field = 'LuaScriptState', default = ''},\n    locked  = {field = 'Locked',  default = false},\n    tooltip = {field = 'Tooltip', default = true},\n    guid    = {field = 'GUID',    default = 'deadbf'},\n    hands   = {field = 'Hands',   default = true},\n}\n-- Apply some basic parameters on base JSON object\nfunction Decker.SetCommonOptions(obj, options)\n    options = options or {}\n    for k,v in pairs(commonMap) do\n        -- can't use and/or logic cause of boolean fields\n        if options[k] ~= nil then\n            obj[v.field] = options[k]\n        else\n            obj[v.field] = v.default\n        end\n    end\n    -- passthrough unrecognized keys\n    for k,v in pairs(options) do\n        if not commonMap[k] then\n            obj[k] = v\n        end\n    end\nend\n-- default spawnObjectJSON/spawnObjectData params since it doesn't like blank fields\nlocal function defaultParams(params)\n    params = params or {}\n    params.position = params.position or {0, 5, 0}\n    params.rotation = params.rotation or {0, 0, 0}\n    params.scale = params.scale or {1, 1, 1}\n    if params.sound == nil then\n        params.sound = true\n    end\n    return params\nend\n\n-- For copy method\nlocal deepcopy\ndeepcopy = function(t)\n    local copy = {}\n    for k,v in pairs(t) do\n       if type(v) == 'table' then\n           copy[k] = deepcopy(v)\n       else\n           copy[k] = v\n       end\n    end\n    return copy\nend\n-- meta for all Decker derived objects\nlocal commonMeta = {\n    -- return object JSON string, used cached if present\n    _cache = function(self)\n        if not self.json then\n            self.json = JSON.encode(self.data)\n        end\n        return self.json\n    end,\n    -- invalidate JSON string cache\n    _recache = function(self)\n        self.json = nil\n        return self\n    end,\n    spawn = function(self, params)\n        params = defaultParams(params)\n        params.data = self.data\n        return spawnObjectData(params)\n    end,\n    spawnJSON = function(self, params)\n        params = defaultParams(params)\n        params.json = self:_cache()\n        return spawnObjectJSON(params)\n    end,\n    copy = function(self)\n        return setmetatable(deepcopy(self), getmetatable(self))\n    end,\n    setCommon = function(self, options)\n        Decker.SetCommonOptions(self.data, options)\n        return self\n    end,\n}\n-- apply common part on a specific metatable\nlocal function customMeta(mt)\n    for k,v in pairs(commonMeta) do\n        mt[k] = v\n    end\n    mt.__index = mt\n    return mt\nend\n\n-- DeckerCard metatable\nlocal cardMeta = {\n    setAsset = function(self, asset)\n        local cardIndex = self.data.CardID:sub(-2, -1)\n        self.data.CardID = asset.id .. cardIndex\n        self.data.CustomDeck = {[asset.id] = asset.data}\n        return self:_recache()\n    end,\n    getAsset = function(self)\n        local deckID = next(self.data.CustomDeck)\n        return assetFromData(self.data.CustomDeck[deckID])\n    end,\n    -- reset deck ID to a consistent value script-wise\n    _recheckDeckID = function(self)\n        local oldID = next(self.data.CustomDeck)\n        local correctID = assetID(self.data.CustomDeck[oldID])\n        if oldID ~= correctID then\n            local cardIndex = self.data.CardID:sub(-2, -1)\n            self.data.CardID = correctID .. cardIndex\n            self.data.CustomDeck[correctID] = self.data.CustomDeck[oldID]\n            self.data.CustomDeck[oldID] = nil\n        end\n        return self\n    end\n}\ncardMeta = customMeta(cardMeta)\n-- Create a DeckerCard from an asset\nfunction Decker.Card(asset, row, col, options)\n    row, col = row or 1, col or 1\n    options = options or {}\n    local card = Decker.BaseObject()\n    card.Name = 'Card'\n    -- optional custom fields\n    Decker.SetCommonOptions(card, options)\n    if options.sideways ~= nil then\n        card.SidewaysCard = options.sideways\n        -- FIXME passthrough set that field, find some more elegant solution\n        card.sideways = nil\n    end\n    -- CardID string is parent deck ID concat with its 0-based index (always two digits)\n    local num = (row-1)*asset.data.NumWidth + col - 1\n    num = string.format('%02d', num)\n    card.CardID = asset.id .. num\n    -- just the parent asset reference needed\n    card.CustomDeck = {[asset.id] = asset.data}\n\n    local obj = setmetatable({data = card}, cardMeta)\n    obj:_recache()\n    return obj\nend\n\n\n-- DeckerDeck meta\nlocal deckMeta = {\n    count = function(self)\n        return #self.data.DeckIDs\n    end,\n    -- Transform index into positive\n    index = function(self, ind)\n        if ind < 0 then\n            return self:count() + ind + 1\n        else\n            return ind\n        end\n    end,\n    swap = function(self, i1, i2)\n        local ri1, ri2 = self:index(i1), self:index(i2)\n        assert(ri1 > 0 and ri1 <= self:count(), 'DeckObj.rearrange: index ' .. i1 .. ' out of bounds')\n        assert(ri2 > 0 and ri2 <= self:count(), 'DeckObj.rearrange: index ' .. i2 .. ' out of bounds')\n        self.data.DeckIDs[ri1], self.data.DeckIDs[ri2] = self.data.DeckIDs[ri2], self.data.DeckIDs[ri1]\n        local co = self.data.ContainedObjects\n        co[ri1], co[ri2] = co[ri2], co[ri1]\n        return self:_recache()\n    end,\n    -- rebuild self.data.CustomDeck based on contained cards\n    _rescanUsedDecks = function(self)\n        local cardIDs = {}\n        for k,card in ipairs(self.data.ContainedObjects) do\n            local cardID = next(card.CustomDeck)\n            if not cardIDs[cardID] then\n                cardIDs[cardID] = card.CustomDeck[cardID]\n            end\n        end\n        -- eeh, GC gotta earn its keep as well\n        -- FIXME if someone does shitton of removals, may cause performance issues?\n        self.data.CustomDeck = cardIDs\n    end,\n    -- rebuild self.data.DeckIDs based on contained cards\n    _rescanDeckIDs = function(self)\n        local deckIDs = {}\n        for _, card in ipairs(self.data.ContainedObjects) do\n            table.insert(deckIDs, card.CardID)\n        end\n        self.data.DeckIDs = deckIDs\n    end,\n    remove = function(self, ind, skipRescan)\n        local rind = self:index(ind)\n        assert(rind > 0 and rind <= self:count(), 'DeckObj.remove: index ' .. ind .. ' out of bounds')\n        local card = self.data.ContainedObjects[rind]\n        table.remove(self.data.DeckIDs, rind)\n        table.remove(self.data.ContainedObjects, rind)\n        if not skipRescan then\n            self:_rescanUsedDecks()\n        end\n        return self:_recache()\n    end,\n    removeMany = function(self, ...)\n        local indices = {...}\n        table.sort(indices, function(e1,e2) return self:index(e1) > self:index(e2) end)\n        for _,ind in ipairs(indices) do\n            self:remove(ind, true)\n        end\n        self:_rescanUsedDecks()\n        return self:_recache()\n    end,\n    insert = function(self, card, ind)\n        ind = ind or (self:count() + 1)\n        local rind = self:index(ind)\n        assert(rind > 0 and rind <= (self:count()+1), 'DeckObj.insert: index ' .. ind .. ' out of bounds')\n        table.insert(self.data.DeckIDs, rind, card.data.CardID)\n        table.insert(self.data.ContainedObjects, rind, card.data)\n        local id = next(card.data.CustomDeck)\n        if not self.data.CustomDeck[id] then\n            self.data.CustomDeck[id] = card.data.CustomDeck[id]\n        end\n        return self:_recache()\n    end,\n    reverse = function(self)\n        local s,e = 1, self:count()\n        while s < e do\n            self:swap(s, e)\n            s = s+1\n            e = e-1\n        end\n        return self:_recache()\n    end,\n    sort = function(self, sortFunction)\n        table.sort(self.data.ContainedObjects, sortFunction)\n        self:_rescanDeckIDs()\n        return self:_recache()\n    end,\n    cardAt = function(self, ind)\n        local rind = self:index(ind)\n        assert(rind > 0 and rind <= (self:count()+1), 'DeckObj.insert: index ' .. ind .. ' out of bounds')\n        local card = setmetatable({data = deepcopy(self.data.ContainedObjects[rind])}, cardMeta)\n        card:_recache()\n        return card\n    end,\n    switchAssets = function(self, replaceTable)\n        -- destructure replace table into\n        -- [ID_to_replace] -> [ID_to_replace_with]\n        -- [new_asset_ID] -> [new_asset_data]\n        local idReplace = {}\n        local assets = {}\n        for oldAsset, newAsset in pairs(replaceTable) do\n            assets[newAsset.id] = newAsset.data\n            idReplace[oldAsset.id] = newAsset.id\n        end\n        -- update deckIDs\n        for k,cardID in ipairs(self.data.DeckIDs) do\n            local deckID, cardInd = cardID:sub(1, -3), cardID:sub(-2, -1)\n            if idReplace[deckID] then\n                self.data.DeckIDs[k] = idReplace[deckID] .. cardInd\n            end\n        end\n        -- update CustomDeck data - nil replaced\n        for replacedID in pairs(idReplace) do\n            if self.data.CustomDeck[replacedID] then\n                self.data.CustomDeck[replacedID] = nil\n            end\n        end\n        -- update CustomDeck data - add replacing\n        for _,replacingID in pairs(idReplace) do\n            self.data.CustomDeck[replacingID] = assets[replacingID]\n        end\n        -- update card data\n        for k,cardData in ipairs(self.data.ContainedObjects) do\n            local deckID = next(cardData.CustomDeck)\n            if idReplace[deckID] then\n                cardData.CustomDeck[deckID] = nil\n                cardData.CustomDeck[idReplace[deckID]] = assets[idReplace[deckID]]\n            end\n        end\n        return self:_recache()\n    end,\n    getAssets = function(self)\n        local assets = {}\n        for id,assetData in pairs(self.data.CustomDeck) do\n            assets[#assets+1] = assetFromData(assetData)\n        end\n        return assets\n    end\n}\ndeckMeta = customMeta(deckMeta)\n-- Create DeckerDeck object from DeckerCards\nfunction Decker.Deck(cards, options)\n    assert(#cards > 1, 'Trying to create a Decker.deck with less than 2 cards')\n    local deck = Decker.BaseObject()\n    deck.Name = 'Deck'\n    Decker.SetCommonOptions(deck, options)\n    deck.Hands = false\n    deck.DeckIDs = {}\n    deck.CustomDeck = {}\n    deck.ContainedObjects = {}\n    for _,card in ipairs(cards) do\n        deck.DeckIDs[#deck.DeckIDs+1] = card.data.CardID\n        local id = next(card.data.CustomDeck)\n        if not deck.CustomDeck[id] then\n            deck.CustomDeck[id] = card.data.CustomDeck[id]\n        end\n        deck.ContainedObjects[#deck.ContainedObjects+1] = card.data\n    end\n\n    local obj = setmetatable({data = deck}, deckMeta)\n    obj:_recache()\n    return obj\nend\n-- Create DeckerDeck from an asset using X cards on its sheet\nfunction Decker.AssetDeck(asset, cardNum, options)\n    cardNum = cardNum or asset.data.NumWidth * asset.data.NumHeight\n    local row, col, width = 1, 1, asset.data.NumWidth\n    local cards = {}\n    for k=1,cardNum do\n        cards[#cards+1] = Decker.Card(asset, row, col)\n        col = col+1\n        if col > width then\n            row, col = row+1, 1\n        end\n    end\n    return Decker.Deck(cards, options)\nend\n\nDecker.RescanExistingDeckIDs = recheckNextID\n\nreturn Decker\n\nend)\nreturn __bundle_require(\"__root\")",
      "LuaScriptState": "[true,2]",
      "XmlUI": ""
    }
  ]
}